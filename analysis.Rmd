---
title: "PRA 2. Limpieza y análisis de datos"
output:
  pdf_document:
    toc: yes
    toc_depth: '2'
  html_document:
    df_print: paged
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
---

```{r}
#install.packages("dplyr")
#install.packages("stringi")
#install.packages("igraph")
library(dplyr)
library(stringi)
library(igraph)
```

# Descripción del dataset. 

El dataset elegido corresponde al generado en la PRAC1. El dataset contiene los resultados obtenidos por distintos equipos profesionales de fútbol en diversas competiciones a lo largo de la última década.

Nos serviremos de estos datos para anlizar los diferentes clubs de fútbol a nivel global así como para buscar patrones entre ellos.

```{r}
df <- read.csv(file = 'football_competitions.csv')
head(df)
```
```{r}
str(df)
```


El fichero contiene una tabla con diez columnas, siendo las dos primeras de tipo cadena y el resto de tipo entero.

Los campos son: 


* competition:  Nombre de la competición, año y grupo dentro de los cuales el equipo
indicado obtuvo los resultados indicados.
* pl_team: Nombre del equipo.
* pl_pi: Número de partidos jugados.
* pl_w: Número de partidos ganados.
* pl_d: Número de partidos empatados.
* pl_l: Número de partidos perdidos.
* pl_f: Número de goles a favor.
* pl_a: Número de goles en contra.
* pl_gd: Diferencia de goles.
* pl_pts: Puntos obtenidos por el equipo.


# Integración y selección de los datos de interés a analizar

Algunos de los campos del dataset original son redundantes.
Como podemos ver, esto sucede con el campo relativo a la diferencia de goles, que se puede calcular a partir de los goles a favor y en contra.

```{r}
max(df$pl_a - df$pl_f + df$pl_gd)
```

Además, el total de partidos jugados se puede calcular mediante la suma de los partidos ganados, perdidos y empatados.

```{r}
max(df$pl_pi - df$pl_w - df$pl_d -df$pl_l)
```

Hemos visto mediante una suma de comprobación que estas columnas son consistentes.
No obstante, debemos excluir los campos redundantes para evitar la multicolinealidad en el dataset.


```{r}
df_clean <- df[,c('pl_w','pl_d','pl_l','pl_f','pl_a','pl_pts')]
```

Como comprobación adicional en relación al número de partidos jugados, observamos que no necesariamente todos los equipos juegan el mismo número de partidos dentro de una misma competición.

```{r}
comp_variation <- df %>% group_by(df$competition) %>% summarise(variacion_partidos = sd(pl_pi))
comp_variation <- comp_variation[comp_variation$variacion_partidos > 0,]
comp_variation
```

Dado que el campo competición tiene una naturaleza jerárquica, vamos a descomponerlo en tres campos:
- comp: nombre de la competición
- group: nombre del grupo dentro de dicha competición
- begin: año de inicio de la competición
- end: año de finalización de la competición

```{r}
# Separar competicion, grupo y año
intermediate_comp <- stri_match(df$competition, regex="(.*?)[ ]*([^ ]*\\d)$")
intermediate_comp_name <- stri_match(intermediate_comp[,2], regex="(.*?)[ ]+-[ ]+(.*)")
df_clean[is.na(intermediate_comp_name[,1]), 'comp'] <- 
  intermediate_comp[is.na(intermediate_comp_name[,1]),2]
df_clean[is.na(intermediate_comp_name[,1]), 'group'] <- NA
df_clean[!is.na(intermediate_comp_name[,1]), 'comp'] <-
  intermediate_comp_name[!is.na(intermediate_comp_name[,1]),2]
df_clean[!is.na(intermediate_comp_name[,1]), 'group'] <-
  intermediate_comp_name[!is.na(intermediate_comp_name[,1]),3]
intermediate_comp_year <- 
  stri_match(intermediate_comp[,3], regex="(.*)/(.*)")
# Añadir año de comienzo y año de fin.
df_clean[is.na(intermediate_comp_year[,1]),'begin'] <-
  as.integer(intermediate_comp[is.na(intermediate_comp_year[,1]),3])
df_clean[is.na(intermediate_comp_year[,1]),'end'] <-
  as.integer(intermediate_comp[is.na(intermediate_comp_year[,1]),3])
df_clean[!is.na(intermediate_comp_year[,1]),'begin'] <-
  as.integer(intermediate_comp_year[!is.na(intermediate_comp_year[,1]),2])
df_clean[!is.na(intermediate_comp_year[,1]),'end'] <-
  as.integer(paste("20", intermediate_comp_year[!is.na(intermediate_comp_year[,1]),3], sep=""))
```

Eliminamos el asterisco que aparece al final de algunos nombres de equipos:

```{r}
df_clean$pl_team <- stri_match(df$pl_team, regex="([^\\*]*)( \\*)?")[,2]
df_clean$pl_team <- stri_match(df_clean$pl_team, regex="(.*[^ ])( )*")[,2]
```

Observamos que algunas de las competiciones son femeninas o sub-21, con lo que añadimos dos campos más para identificar dichas competiciones:
- female: booleano que indica si la competición es femenina
- sub21: booleano que indica si la competición es sub-21

```{r}
df_clean$female <- !is.na(stri_match(df_clean$comp, regex="Women"))
df_clean$sub21 <- !is.na(stri_match(df_clean$comp, regex="U(nder)?( )*-( )*?21")[,1])
```

Basándonos en que el dataset incluye diversas ligas junto con competiciones entre distintas selecciones nacionales, vamos a identificar la manera en la cual se relacionan los equipos entre sí y dentro de cada competición. Para ello vamos a considerar cada registro del dataset como una arista de un grafo bipartito que incluye por un lado los equipos y por otro lado las competiciones.

```{r}
b <- df_clean[,c("comp","pl_team")] %>% distinct()
n <- length(b[,1])
g <- c()
for (i in 1:n ){
g <- c(g, paste( "C:", b[i,"comp"]), paste("T:", b[i,"pl_team"]))
}
graph <- make_graph(g, directed=FALSE)
```

Sobre este grafo, vamos a lanzar un algoritmo de detección de comunidades que nos muestre a que grupos pertenecen los distintos equipos y competiciones. Añadimos al dataset los siguientes campos:
- comp_comm: entero que identifica la comunidad a la cual pertenece la competición
- team_comm: entero que identifica la comunidad a la cual pertenece el equipo

```{r}
fc <- fastgreedy.community(graph)
df_clean$comp_comm <- membership(fc)[paste("C:",df_clean$comp)]
df_clean$team_comm <- membership(fc)[paste("T:",df_clean$pl_team)]
```

# Limpieza de datos

## Elementos vacíos y cero.

Primero vamos a ver si hay valores vacíos en el dataset.

```{r}
sapply(df_clean, function(x) sum(is.na(x)))
```

Unicamente los hay en el campo group, que hemos añadido. Se corresponden a ligas en las cuales no hay una subdivisión por grupos. 

Buscamos valores 0.

```{r}
sum(df_clean[,c('pl_w','pl_d','pl_l',
            'pl_f','pl_a','pl_pts',
            'begin','end')]==0)
```
Hay muchos datos que son igual a cero. Debido a la naturaleza del dataframe no es necesario quitarlos, porque puede ser que un equipo tenga 0 puntos, victorias, derrotas, etc.

## Valores extremos.

Para la detección de outliers o valores extremos utilizamos la función boxplots.stats(), en concreto el atributo "out" que nos devuelve los valores que distan mucho del rango intercuartílico que se dibujan en los diagramas de caja.

```{r}
boxplot.stats(df_clean$pl_w)$out
```

```{r}
boxplot.stats(df_clean$pl_d)$out
```

```{r}
boxplot.stats(df_clean$pl_l)$out
```

```{r}
boxplot.stats(df_clean$pl_f)$out
```

```{r}
boxplot.stats(df_clean$pl_a)$out
```

A penas hay valores outliers y tras comprobarlos, vemos que efectivamente hay equipos que han ganado más de 30 partidos en una competición y lo mismo ocurre con las derrotas y los goles en contra.

Finalmente guardamos la versión limpia y estable del dataset, en la cual nos basaremos para realizar el análisis.

```{r}
#write.csv(df_clean, 'clean.csv')
df_final <- read.csv(file = 'clean.csv')
```

# Análisis de los datos.

## Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar).

Queremos estudiar diferencias cualitativas entre las comunidades identificadas durante la fase de integración de datos. El algoritmo ha identificado 15 comunidades distintas.

```{r}
max(df_final$comp_comm)
```

El grafo formado por los equipos y las competiciones, dentro de sus respectivas comunidades, queda entonces representado de la siguiente manera:

```{r}
colors <- rainbow(max(membership(fc)))

bb <- df_clean[,c("pl_team", "team_comm")] %>% distinct()
bbb <- df_clean[,c("comp", "comp_comm")] %>% distinct()
comm <- list()
n <- length(bb[,1])
for (i in 1:n ){
comm[paste("T:",bb[i,"pl_team"])] <- bb[i,"team_comm"]
}
n <- length(bbb[,1])
for (i in 1:n ){
comm[paste("C:",bbb[i,"comp"])] <- bbb[i,"comp_comm"]
}
col <- c()
for (name in V(graph)$name){
  col <- c(col, colors[comm[[name]]])
  
}
plot(graph, vertex.label=NA, vertex.size=15, arrow.width=1,vertex.color=col);legend('topleft',legend=1:max(membership(fc)), pch=20, col=colors)
```

Vemos diferentes componentes conexas, como se espera, debido a que el dataset incluye diferentes categorías y ligas.

Veamos a continuación cuales son las competiciones incluidas en cada una de las comunidades identificadas:


```{r}
unique(as.character(df_final[df_final$comp_comm == 1, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 2, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 3, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 4, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 5, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 6, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 7, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 8, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 9, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 10, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 11, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 12, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 13, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 14, "comp"]))
```

```{r}
unique(as.character(df_final[df_final$comp_comm == 15, "comp"]))
```

Teniendo en cuenta que cada componente conexa puede albergar más de una comunidad, queremos ser capaces de localizar vínculos entre componentes conexas adjacentes. Recordando que cada entrada en el dataset corresponde a un equipo jugando dentro de una competición, y que las comunidades de ambos pueden no coincidir, podemos observar vínculos entre comunidades mediante la siguiente matriz de confusión:

```{r}
table(df_clean$team_comm, df_clean$comp_comm)
```

Podemos, por ejemplo, observar vínculos entre las comunidades 1 y 10, a las cuales corresponden competiciones inglesas.

Dado que, a la vista del grafo y la matriz, las competiciones inglesas son numerosas y parecen estar vinculadas mediante pocos enlaces con el resto de competiciones europeas, vamos a tratar de comparar los promedios de goles y puntuaciones entre estos dos grupos de competiciones.

De esta manera consideramos un grupo A, formado por las comunidades 1 y 10, frente a un grupo B, formado por las comunidades 3, 4, 5, 9.

```{r}
df_A <- df_final[df_final$comp_comm %in% c(1,10), c("pl_f","pl_a","pl_w","pl_pts")]
df_B <- df_final[df_final$comp_comm %in% c(3,4,5,9), c("pl_f","pl_a","pl_w","pl_pts")]
```

TODO: NORMALIZAR VALORES

```{r}
(df_final$pl_f / (df_final$pl_w + df_final$pl_d + df_final$pl_l))[df_final$comp_comm %in% c(1,10),]
(df_final$pl_f / (df_final$pl_w + df_final$pl_d + df_final$pl_l))[df_final$comp_comm %in% c(3,4,5,9),]
```

TODO: considerar tambien grupos Masculino/Femenino, Sub21/Absoluto

## Comprobación de la normalidad y homogeneidad de la varianza.

```{r}
c(mean(df_A$pl_f),mean(df_B$pl_f),mean(df_A$pl_a),mean(df_B$pl_a),
  mean(df_A$pl_w),mean(df_B$pl_w),mean(df_A$pl_pts),mean(df_B$pl_pts))
```


```{r}
c(sd(df_A$pl_f),sd(df_B$pl_f),sd(df_A$pl_a),sd(df_B$pl_a),sd(df_A$pl_w),sd(df_B$pl_w),sd(df_A$pl_pts),sd(df_B$pl_pts))
```

```{r}
data1 <- df_A
data1$pl_f <- (df_final$pl_f / (df_final$pl_w + df_final$pl_d + df_final$pl_l))[df_final$comp_comm %in% c(1,10)]
data1$group <- 'A' 
data2 <- df_B
data2$pl_f <- (df_final$pl_f / (df_final$pl_w + df_final$pl_d + df_final$pl_l))[df_final$comp_comm %in% c(3,4,5,9)]
data2$group <- 'B'
data <- bind_rows(data1,data2)
plot(aov(pl_pts~group, data))
```

TODO: terminar


## Aplicación de pruebas estadísticas para comparar los grupos de datos. En función de los datos y el objetivo del estudio, aplicar pruebas de contraste de hipótesis, correlaciones, regresiones, etc. Aplicar al menos tres métodos de análisis diferentes.

Aquí puede ir  estadísticas de los equipos más destacados y un clustering de equipos 

```{r}
wilcox.test(data$pl_f~data$group)
```

TODO: incorporar los años de las competiciones en un analisis de regresion

TODO: estudiar correlacion entre goles a favor y puntos obtenidos

# Representación de los resultados a partir de tablas y gráficas.

plots de los equipos y un plot del clustering con sus fronteras de decisión

# Resolución del problema. A partir de los resultados obtenidos, ¿cuáles son las conclusiones? ¿Los resultados permiten responder al problema?


